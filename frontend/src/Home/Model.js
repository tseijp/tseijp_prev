// Auto-generated by https://github.com/react-spring/gltfjsx

import * as THREE from "three"
import React, { useEffect, useRef, useState } from "react"
import { useLoader, useFrame } from "react-three-fiber"
import { useControl } from 'react-three-gui';
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader"

export default function Model({ mouse, ...props }) {
    const url = "https://tseijp-static.s3.ap-northeast-1.amazonaws.com/Xbot.glb"
    const group = useRef()
    const { nodes, animations } = useLoader(GLTFLoader, url)
    //const texture = useLoader(THREE.TextureLoader, "/stacy.jpg")
    const actions = useRef()
    const [action, setAction] = useState(0)
    const [mixer] = useState(() => new THREE.AnimationMixer())
    const modelPos  = useControl('model' , {type:"xypad", value:{x:0,y:0} ,scrub:true,distance:10})
    const cameraPos = useControl('camera', {type:"xypad", value:{x:0,y:3} ,scrub:true,distance:10})
    useFrame((state, delta) => mixer.update(delta))
    useFrame(({clock,camera})=>{
        group.current.position.x = modelPos.x
        group.current.position.z = modelPos.y
        camera.updateProjectionMatrix(void (
            camera.position.x=cameraPos.x,
            camera.position.z=cameraPos.y,
            camera.lookAt(new THREE.Vector3(modelPos.x/2,0,modelPos.y/2))))
    })
    useEffect(() => {
        actions.current = { idle: mixer.clipAction(animations[action||1], group.current) }
        actions.current.idle.play()
        actions.current.idle.weight = 1
        actions.current.idle.timeScale = 0.5
        return () => animations.forEach(clip => mixer.uncacheClip(clip))
    }, [action,animations,mixer])
    useControl('Action',{type:"select",value:3  ,state:[action, setAction],items:[...Array(animations.length)].map((_,i)=>i)})
    useControl('Time'  ,{type:"number",value:0.5,max:1,onChange:v=>{actions.current.idle.timeScale=v}})
    useControl('Weight',{type:"number",value:1  ,max:1,onChange:v=>{actions.current.idle.weight=v}})
    useFrame((state, delta) => {
        mixer.update(delta)
        //moveJoint(mouse, nodes.mixamorigNeck)
        //moveJoint(mouse, nodes.mixamorigSpine)
    })
    if (!nodes)
        return

    return (
        <group ref={group} {...props} dispose={null}>
          <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>
            <primitive object={nodes["mixamorigHips"]} />
            <skinnedMesh geometry={nodes["Beta_Joints"].geometry}
                skeleton={nodes["Beta_Joints"].skeleton}
                rotation={[-Math.PI / 2, 0, 0]} scale={[100, 100, 100]}>
                <meshPhongMaterial attach="material" color={0x000000} depthWrite={false} skinning />
            </skinnedMesh>
            <skinnedMesh geometry={nodes["Beta_Surface"].geometry}
                skeleton={nodes["Beta_Surface"].skeleton}
                rotation={[-Math.PI / 2, 0, 0]} scale={[100, 100, 100]}>
                <meshPhongMaterial attach="material" color={0xffffff} depthWrite={false} skinning />
            </skinnedMesh>
          </group>
        </group>
    )
}
